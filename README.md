# UnderGrad_CS_Projects

Juan David Correa
Under Graduate Computer Science Projects 
Made originally in Pascal, circa 1988. 
UPR RUM Mayaguez

Re coded in Python, for modern times. 
Oct-Nov 2024

 
1. Towers of Hanoi
•	Description: A classic recursive problem that involves moving a set of disks from one peg to another, following these rules:
o	Only one disk can be moved at a time.
o	A disk cannot be placed on top of a smaller disk.
o	The task is to move all disks from the source peg to the target peg using an auxiliary peg.
 
2. Binary Search
•	Description: An efficient searching algorithm that finds the position of a target value within a sorted list. It works by repeatedly dividing the search interval in half:
o	If the target value is less than the middle element, narrow the search to the lower half.
o	If greater, narrow to the upper half.
o	Repeat until the target is found or the interval is empty.
 
3. Merge Sort
•	Description: A divide-and-conquer sorting algorithm that:
o	Recursively splits the list into halves until each sublist has one element.
o	Merges sublists back together in sorted order.
o	It has a time complexity of O(nlog⁡n)O(nlogn), making it highly efficient.
 
4. Dijkstra's Algorithm
•	Description: A graph algorithm that finds the shortest path from a starting node to all other nodes in a weighted graph. It uses a priority queue to explore the shortest possible paths first, updating the shortest known distance to each node.
 
5. Breadth-First Search (BFS)
•	Description: A graph traversal algorithm that explores nodes level by level:
o	Starts at a given node and explores all its neighbors.
o	Moves to the neighbors' neighbors next, and so on.
o	Often used for finding the shortest path in an unweighted graph.
 
6. Depth-First Search (DFS)
•	Description: Another graph traversal algorithm that explores as far as possible along one branch before backtracking:
o	Uses a stack (either explicitly or via recursion).
o	Useful for tasks like topological sorting and detecting cycles.
 
7. Knapsack Problem (0/1 Knapsack)
•	Description: A dynamic programming problem where, given a set of items with weights and values, the goal is to determine the maximum value that can be obtained by selecting items such that their total weight does not exceed a given limit.
 
8. Floyd-Warshall Algorithm
•	Description: An algorithm used to find the shortest paths between all pairs of nodes in a weighted graph:
o	It’s a dynamic programming approach that updates the shortest path between nodes by considering all possible intermediate nodes.
o	The time complexity is O(n3).
 
9. Quicksort
•	Description: A highly efficient sorting algorithm that uses a divide-and-conquer approach:
o	Selects a "pivot" element and partitions the list into two sublists: elements less than the pivot and elements greater than the pivot.
o	Recursively sorts the sublists.
o	Has an average-case time complexity of O(nlog⁡n.
 
10. Prim's Algorithm
•	Description: A greedy algorithm that finds the minimum spanning tree of a weighted, undirected graph:
o	Starts with an arbitrary node and grows the tree by adding the smallest edge that connects a new node.
o	Useful for network design and ensuring minimal connection costs.


